"""
Read and write swarm data
"""
import os
import numpy as np
import xarray as xr
import pandas as pd

from .utils import _read_parameters, _read_times, PARAMETERS_FILE

SWARM_BASENAME = "step_"


def read_mandyoc_swarm(path, parameters_file=PARAMETERS_FILE):
    """
    Read swarm files generated by MANDYOC and return the positions of the particles
    in time

    Parameters
    ----------
    path : str
        Path to the folder where the MANDYOC output files are located.
    parameters_file : str (optional)
        Name of the parameters file. It must be located inside the ``path`` directory.
        Default to ``"param_1.5.3.txt"``.

    Returns
    -------
    swarm : :class:`pandas.DataFrame`
        DataFrame containing the particles positions for every time step. The positions
        of the particles are given by ``x``, ``y`` and ``z`` in meters. The ``cc0`` is
        the number assigned to each particle belonging to a finite element. The ``time``
        is given in Ma. The index of the :class:`pandas.DataFrame` correspond to the
        step number.
    """
    # Determine the number of time steps and dimension of data
    parameters = _read_parameters(os.path.join(path, parameters_file))
    dimension = len(parameters["shape"])
    print_step = parameters["print_step"]
    max_steps = parameters["stepMAX"]
    steps, times = _read_times(path, print_step, max_steps)
    # Get swarm files
    swarm_files = [i for i in os.listdir(path) if SWARM_BASENAME in i]
    # Initialize the list of dataframes that will be concatenated
    dataframes = []
    # Read the data
    for i, (step, time) in enumerate(zip(steps, times)):
        # Determine the rank value on the first step and check it for following steps
        step_files = [
            i for i in swarm_files if "{}{}-".format(SWARM_BASENAME, step) in i
        ]
        if i == 0:
            n_rank = len(step_files)
        else:
            if len(step_files) != n_rank:
                raise ValueError(
                    "Invalid number of ranks '{}' for step '{}'".format(
                        len(step_files), step
                    )
                )
        # Read particles positions for the current step
        dataframes.append(
            _read_mandyoc_single_swarm(path, step, time, n_rank, dimension)
        )
    # Concatenate the dataframes
    swarm = pd.concat(dataframes)
    return swarm


def _read_mandyoc_single_swarm(path, step, time, n_rank, dimension):
    """
    Read swarm positions for a single time step from MANDYOC output files
    """
    x, y, z, cc0 = tuple(np.array([]) for i in range(4))
    for rank_i in range(n_rank):
        filename = "{}{}-rank_new{}.txt".format(SWARM_BASENAME, step, rank_i)
        if dimension == 2:
            x_rank, z_rank, cc0_rank = np.loadtxt(
                os.path.join(path, filename), unpack=True, usecols=(0, 1, 2)
            )
        elif dimension == 3:
            x_rank, y_rank, z_rank, cc0_rank = np.loadtxt(
                os.path.join(path, filename), unpack=True, usecols=(0, 1, 2, 3)
            )
        # Stack arrays in sequence horizontally
        cc0 = np.hstack((cc0, cc0_rank))
        x = np.hstack((x, x_rank))
        z = np.hstack((z, z_rank))
        if dimension == 3:
            y = np.hstack((y, y_rank))
    # Create a data frame for the current step
    data = {"x": x, "z": z, "cc0": cc0, "time": time}
    if dimension == 3:
        data["y"] = y
    df = pd.DataFrame(data=data, index=np.full_like(x, step, dtype=int))
    return df
