"""
Read and write swarm data
"""
import os
import numpy as np
import xarray as xr
import pandas as pd

from .utils import _read_parameters, _read_times, PARAMETERS_FILE

SWARM_BASENAME = "step_"


def read_md3d_swarm(path, parameters_file=PARAMETERS_FILE):
    """
    Read swarm files generated by MD3D and return the positions of the particles in time

    Parameters
    ----------
    path : str
        Path to the folder where the MD3D output files are located.
    parameters_file : str (optional)
        Name of the parameters file. It must be located inside the ``path`` directory.
        Default to ``"param_1.5.3.txt"``.

    Returns
    -------
    swarm : :class:`xarray.Dataset`
        :class:`xarray.Dataset` containing the particles positions for every time step.
        The positions of the particles are given by ``x``, ``y`` and ``z`` in meters.
        The ``cc0`` is the number assigned to each particle belonging to a finite
        element. The ``time`` is given in Ma.
    """
    # Determine the number of time steps
    parameters = _read_parameters(os.path.join(path, parameters_file))
    print_step = parameters["print_step"]
    max_steps = parameters["stepMAX"]
    steps, times = _read_times(path, print_step, max_steps)
    # Get swarm files
    swarm_files = [i for i in os.listdir(path) if SWARM_BASENAME in i]
    # Initialize the list of dataframes that will be concatenated
    dataframes = []
    # Read the data
    for i, (step, time) in enumerate(zip(steps, times)):
        # Determine the rank value on the first step and check it for following steps
        step_files = [
            i for i in swarm_files if "{}{}-".format(SWARM_BASENAME, step) in i
        ]
        if i == 0:
            n_rank = len(step_files)
        else:
            if len(step_files) != n_rank:
                raise ValueError(
                    "Invalid number of ranks '{}' for step '{}'".format(
                        len(step_files), step
                    )
                )
        # Read particles positions for the current step
        dataframes.append(_read_md3d_single_swarm(path, step, time, n_rank))
    # Concatenate the dataframes
    swarm = pd.concat(dataframes)
    # Convert the swarm into a xr.Dataset
    dims = ["step"]
    coords = {"step": ("step", swarm.index), "time": ("step", swarm.time)}
    data_vars = {
        "x": (dims, swarm.x),
        "y": (dims, swarm.y),
        "z": (dims, swarm.z),
        "cc0": (dims, swarm.cc0),
    }
    swarm = xr.Dataset(data_vars, coords=coords, attrs=parameters)
    return swarm


def _read_md3d_single_swarm(path, step, time, n_rank):
    """
    Read swarm positions for a single time step from MD3D output files
    """
    x, y, z, cc0 = tuple(np.array([]) for i in range(4))
    for rank_i in range(n_rank):
        filename = "{}{}-rank_new{}.txt".format(SWARM_BASENAME, step, rank_i)
        x_rank, y_rank, z_rank, cc0_rank = np.loadtxt(
            os.path.join(path, filename), unpack=True, usecols=(0, 1, 2, 3)
        )
        # Stack arrays in sequence horizontally
        cc0 = np.hstack((cc0, cc0_rank))
        x = np.hstack((x, x_rank))
        y = np.hstack((y, y_rank))
        z = np.hstack((z, z_rank))
    # Create a data frame for the current step
    data = {"x": x, "y": y, "z": z, "cc0": cc0, "time": time}
    df = pd.DataFrame(data=data, index=step * np.ones_like(x, dtype=int))
    return df
